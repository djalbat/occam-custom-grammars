[
  {
    "name": "Default",
    "termBNF": "term                                 ::=  \"(\" argument \")\"\n\n                                       |  variable \n                                       \n                                       ;",
    "statementBNF": "statement                            ::=  \"(\" metaArgument \")\" \n                                                  \n                                       |  equality\n\n                                       |  judgement\n\n                                       |  typeAssertion \n                                                  \n                                       |  definedAssertion  \n\n                                       |  containedAssertion  \n                                       \n                                       |  satisfiesAssertion\n\n                                       |  subproofAssertion         \n\n                                       |  propertyAssertion  \n\n                                       |  metavariable ( frameSubstitution | termSubstitution )?\n\n                                       ;\n\nequality                             ::=  term \"=\" term ;\n\ntypeAssertion                        ::=  term \":\" type ;\n\ndefinedAssertion                     ::=  ( frame | term ) \"is\" ( \"defined\" | \"undefined\" );\n\ncontainedAssertion                   ::=  ( frame | term ) \"is\" ( \"present\" | \"missing\" ) \"in\" statement ;\n\nsatisfiesAssertion                   ::=  signature \"satisfies\" metavariable ;  \n\nsubproofAssertion                    ::=  \"[\" statement ( \",\" statement )* \"]\" \"...\" statement ;\n\npropertyAssertion                    ::=  term \"is\" ( \"a\" | \"an\" ) propertyRelation ;\n\npropertyRelation                     ::=  property \"of\" term ;\n\njudgement                            ::=  frame \"|-\" declaration ;\n\nframe                                ::=  \"[\" declaration ( \",\" declaration )* \"]\" ;\n \ndeclaration                          ::=  metavariable ( \"::\" statement )? ;\n\ntermSubstitution                     ::=  \"[\" term \"for\" term \"]\";\n\nframeSubstitution                    ::=  \"[\" frame \"for\" frame \"]\";\n\nstatementSubstitution                ::=  \"[\" statement \"for\" statement \"]\";\n\nreferenceSubstitution                ::=  \"[\" reference \"for\" reference \"]\";",
    "typeVocabulary": "_\n",
    "symbolVocabulary": ""
  },
  {
    "name": "minimal-propositional-logic",
    "termBNF": "",
    "statementBNF": "\n\n             statement  ::=   \"¬\"<NO_WHITESPACE>metaArgument\n\n                          |   metaArgument ( \"∧\" | \"∨\" | \"⇒\" | \"𝘪𝘧𝘧\" ) metaArgument\n\n                          ;\n\n",
    "typeVocabulary": "",
    "symbolVocabulary": "𝘪𝘧𝘧\n⇒\n∧\n∨\n¬\n"
  },
  {
    "name": "intuitionistic-propositional-logic",
    "termBNF": "",
    "statementBNF": "",
    "typeVocabulary": "",
    "symbolVocabulary": ""
  },
  {
    "name": "classical-propositional-logic",
    "termBNF": "",
    "statementBNF": "",
    "typeVocabulary": "",
    "symbolVocabulary": ""
  },
  {
    "name": "de-morgans-laws",
    "termBNF": "",
    "statementBNF": "",
    "typeVocabulary": "",
    "symbolVocabulary": ""
  },
  {
    "name": "numbers",
    "termBNF": "\n\n                       term  ::=  \"𝘻𝘦𝘳𝘰\" ;\n\n",
    "statementBNF": "",
    "typeVocabulary": "ℝ\\{0}\nℚ\\{0}\nℤ\\{0}\nℕ\\{0}\nℝ\nℚ\nℤ\nℕ\n",
    "symbolVocabulary": "𝘻𝘦𝘳𝘰\n"
  },
  {
    "name": "equality",
    "termBNF": "",
    "statementBNF": "\n\n            statement  ::=  argument \"≠\" argument\n\n                         |  argument \"=\" argument \"=\" argument \n \n                         ;\n\n",
    "typeVocabulary": "",
    "symbolVocabulary": ""
  },
  {
    "name": "collections",
    "termBNF": "",
    "statementBNF": "\n\n                statement  ::=  argument ( \"∈⁺\" | \"∉⁺\" | \"∈\" | \"∉\" ) argument ;\n\n",
    "typeVocabulary": "𝖢𝗈𝗅𝗅𝖾𝖼𝗍𝗂𝗈𝗇\n𝖤𝗅𝖾𝗆𝖾𝗇𝗍\n",
    "symbolVocabulary": "∈⁺\n∉⁺\n∈\n∉\n"
  },
  {
    "name": "groups",
    "termBNF": "\n\n                               term  ::=  ( \"𝓮_\" | \"∘_\" )<NO_WHITESPACE>argument\n\n                                       |  argument argument argument     (1)\n\n                                       |  argument<NO_WHITESPACE>\"⁻¹\"    (2)\n\n                                       ;\n\n",
    "statementBNF": "",
    "typeVocabulary": "𝖦𝗋𝗈𝗎𝗉\n𝖮𝗉𝖾𝗋𝖺𝗍𝗂𝗈𝗇\n𝖨𝖽𝖾𝗇𝗍𝗂𝗍𝗒𝖤𝗅𝖾𝗆𝖾𝗇𝗍\n",
    "symbolVocabulary": "⁻¹\n𝓮_\n∘_\n"
  }
]