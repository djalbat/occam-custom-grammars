"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _necessary = require("necessary");
var _nominal = require("./utilities/nominal");
var _ruleNames = require("./ruleNames");
var _constants = require("./constants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var first = _necessary.arrayUtilities.first;
var _obj;
var ruleMap = _nominal.nominalParser.getRuleMap(), stuffRule = ruleMap[_constants.STUFF_RULE_NAME], nonsenseRule = ruleMap[_constants.NONSENSE_RULE_NAME], stuffTypes = typesFromRule(stuffRule), nonsenseTypes = typesFromRule(nonsenseRule), termTypes = stuffTypes, statementTypes = nonsenseTypes, typesMap = (_obj = {}, _define_property(_obj, _ruleNames.TERM_RULE_NAME, termTypes), _define_property(_obj, _ruleNames.STATEMENT_RULE_NAME, statementTypes), _obj);
var _default = typesMap;
function typesFromRule(rule) {
    var parts;
    var definitions = rule.getDefinitions(), firstDDefinition = first(definitions), definition = firstDDefinition; ///
    parts = definition.getParts();
    var firstPart = first(parts), oneOrMorePartsPart = firstPart, part = oneOrMorePartsPart.getPart(), choiceOrPartsPart = part; ///
    parts = choiceOrPartsPart.getParts();
    var types = parts.map(function(part) {
        var significantTokenTypePart = part, significantTokenType = significantTokenTypePart.getSignificantTokenType(), type = significantTokenType; ///
        return type;
    });
    return types;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90eXBlc01hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IG5vbWluYWxQYXJzZXIgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9taW5hbFwiO1xuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUsIFNUQVRFTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFNUVUZGX1JVTEVfTkFNRSwgTk9OU0VOU0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jb25zdCBydWxlTWFwID0gbm9taW5hbFBhcnNlci5nZXRSdWxlTWFwKCksXG4gICAgICBzdHVmZlJ1bGUgPSBydWxlTWFwW1NUVUZGX1JVTEVfTkFNRV0sXG4gICAgICBub25zZW5zZVJ1bGUgPSBydWxlTWFwW05PTlNFTlNFX1JVTEVfTkFNRV0sXG4gICAgICBzdHVmZlR5cGVzID0gdHlwZXNGcm9tUnVsZShzdHVmZlJ1bGUpLFxuICAgICAgbm9uc2Vuc2VUeXBlcyA9IHR5cGVzRnJvbVJ1bGUobm9uc2Vuc2VSdWxlKSxcbiAgICAgIHRlcm1UeXBlcyA9IHN0dWZmVHlwZXMsIC8vL1xuICAgICAgc3RhdGVtZW50VHlwZXMgPSBub25zZW5zZVR5cGVzLFxuICAgICAgdHlwZXNNYXAgPSB7XG4gICAgICAgIFtURVJNX1JVTEVfTkFNRV06IHRlcm1UeXBlcyxcbiAgICAgICAgW1NUQVRFTUVOVF9SVUxFX05BTUVdOiBzdGF0ZW1lbnRUeXBlc1xuICAgICAgfTtcblxuZXhwb3J0IGRlZmF1bHQgdHlwZXNNYXA7XG5cbmZ1bmN0aW9uIHR5cGVzRnJvbVJ1bGUocnVsZSkge1xuICBsZXQgcGFydHM7XG5cbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksXG4gICAgICAgIGZpcnN0RERlZmluaXRpb24gPSBmaXJzdChkZWZpbml0aW9ucyksXG4gICAgICAgIGRlZmluaXRpb24gPSBmaXJzdEREZWZpbml0aW9uOyAgLy8vXG5cbiAgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgY29uc3QgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBvbmVPck1vcmVQYXJ0c1BhcnQgPSBmaXJzdFBhcnQsIC8vL1xuICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKSxcbiAgICAgICAgY2hvaWNlT3JQYXJ0c1BhcnQgPSBwYXJ0OyAvLy9cblxuICBwYXJ0cyA9IGNob2ljZU9yUGFydHNQYXJ0LmdldFBhcnRzKCk7XG5cbiAgY29uc3QgdHlwZXMgPSBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQuZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUoKSxcbiAgICAgICAgICB0eXBlID0gc2lnbmlmaWNhbnRUb2tlblR5cGU7ICAvLy9cblxuICAgIHJldHVybiB0eXBlO1xuICB9KTtcblxuICByZXR1cm4gdHlwZXM7XG59XG4iXSwibmFtZXMiOlsiZmlyc3QiLCJhcnJheVV0aWxpdGllcyIsInJ1bGVNYXAiLCJub21pbmFsUGFyc2VyIiwiZ2V0UnVsZU1hcCIsInN0dWZmUnVsZSIsIlNUVUZGX1JVTEVfTkFNRSIsIm5vbnNlbnNlUnVsZSIsIk5PTlNFTlNFX1JVTEVfTkFNRSIsInN0dWZmVHlwZXMiLCJ0eXBlc0Zyb21SdWxlIiwibm9uc2Vuc2VUeXBlcyIsInRlcm1UeXBlcyIsInN0YXRlbWVudFR5cGVzIiwidHlwZXNNYXAiLCJURVJNX1JVTEVfTkFNRSIsIlNUQVRFTUVOVF9SVUxFX05BTUUiLCJydWxlIiwicGFydHMiLCJkZWZpbml0aW9ucyIsImdldERlZmluaXRpb25zIiwiZmlyc3RERGVmaW5pdGlvbiIsImRlZmluaXRpb24iLCJnZXRQYXJ0cyIsImZpcnN0UGFydCIsIm9uZU9yTW9yZVBhcnRzUGFydCIsInBhcnQiLCJnZXRQYXJ0IiwiY2hvaWNlT3JQYXJ0c1BhcnQiLCJ0eXBlcyIsIm1hcCIsInNpZ25pZmljYW50VG9rZW5UeXBlUGFydCIsInNpZ25pZmljYW50VG9rZW5UeXBlIiwiZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUiLCJ0eXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFzQkE7OztlQUFBOzs7eUJBcEIrQjt1QkFFRDt5QkFDc0I7eUJBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRXBELElBQU0sQUFBRUEsUUFBVUMseUJBQWMsQ0FBeEJEO0lBU1M7QUFQakIsSUFBTUUsVUFBVUMsc0JBQWEsQ0FBQ0MsVUFBVSxJQUNsQ0MsWUFBWUgsT0FBTyxDQUFDSSwwQkFBZSxDQUFDLEVBQ3BDQyxlQUFlTCxPQUFPLENBQUNNLDZCQUFrQixDQUFDLEVBQzFDQyxhQUFhQyxjQUFjTCxZQUMzQk0sZ0JBQWdCRCxjQUFjSCxlQUM5QkssWUFBWUgsWUFDWkksaUJBQWlCRixlQUNqQkcsWUFBVyxXQUNULGlCQURTLE1BQ1JDLHlCQUFjLEVBQUdILFlBQ2xCLGlCQUZTLE1BRVJJLDhCQUFtQixFQUFHSCxpQkFGZDtJQUtqQixXQUFlQztBQUVmLFNBQVNKLGNBQWNPLElBQUk7SUFDekIsSUFBSUM7SUFFSixJQUFNQyxjQUFjRixLQUFLRyxjQUFjLElBQ2pDQyxtQkFBbUJyQixNQUFNbUIsY0FDekJHLGFBQWFELGtCQUFtQixHQUFHO0lBRXpDSCxRQUFRSSxXQUFXQyxRQUFRO0lBRTNCLElBQU1DLFlBQVl4QixNQUFNa0IsUUFDbEJPLHFCQUFxQkQsV0FDckJFLE9BQU9ELG1CQUFtQkUsT0FBTyxJQUNqQ0Msb0JBQW9CRixNQUFNLEdBQUc7SUFFbkNSLFFBQVFVLGtCQUFrQkwsUUFBUTtJQUVsQyxJQUFNTSxRQUFRWCxNQUFNWSxHQUFHLENBQUMsU0FBQ0o7UUFDdkIsSUFBTUssMkJBQTJCTCxNQUMzQk0sdUJBQXVCRCx5QkFBeUJFLHVCQUF1QixJQUN2RUMsT0FBT0Ysc0JBQXVCLEdBQUc7UUFFdkMsT0FBT0U7SUFDVDtJQUVBLE9BQU9MO0FBQ1QifQ==