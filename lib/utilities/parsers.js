"use strict";

var _occamLexers = require("occam-lexers");

var _necessary = require("necessary");

var _occamParsers = require("occam-parsers");

var push = _necessary.arrayUtilities.push,
    _parsers = parsers,
    termDefaultCustomGrammarBNF = _parsers.termDefaultCustomGrammarBNF,
    statementDefaultCustomGrammarBNF = _parsers.statementDefaultCustomGrammarBNF,
    expressionDefaultCustomGrammarBNF = _parsers.expressionDefaultCustomGrammarBNF,
    metastatementDefaultCustomGrammarBNF = _parsers.metastatementDefaultCustomGrammarBNF;

function florenceParserFromCombinedCustomGrammar(combinedCustomGrammar) {
  var bnf = _occamParsers.FlorenceParser.bnf,
      florenceParser = florenceParserFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar);
  return florenceParser;
}

function florenceParserFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar) {
  var combinedCustomGrammarRules = combinedCustomGrammar.getRules(),
      bnfLexer = _occamLexers.BNFLexer.fromNothing(),
      bnfParser = _occamParsers.BNFParser.fromNothing(),
      tokens = bnfLexer.tokensFromBNF(bnf),
      rules = bnfParser.rulesFromTokens(tokens);

  push(rules, combinedCustomGrammarRules);
  var florenceParser = new _occamParsers.FlorenceParser(rules);
  return florenceParser;
}

module.exports = {
  termDefaultCustomGrammarBNF: termDefaultCustomGrammarBNF,
  statementDefaultCustomGrammarBNF: statementDefaultCustomGrammarBNF,
  expressionDefaultCustomGrammarBNF: expressionDefaultCustomGrammarBNF,
  metastatementDefaultCustomGrammarBNF: metastatementDefaultCustomGrammarBNF,
  florenceParserFromCombinedCustomGrammar: florenceParserFromCombinedCustomGrammar,
  florenceParserFromBNFAndCombinedCustomGrammar: florenceParserFromBNFAndCombinedCustomGrammar
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlcnMuanMiXSwibmFtZXMiOlsicHVzaCIsImFycmF5VXRpbGl0aWVzIiwicGFyc2VycyIsInRlcm1EZWZhdWx0Q3VzdG9tR3JhbW1hckJORiIsInN0YXRlbWVudERlZmF1bHRDdXN0b21HcmFtbWFyQk5GIiwiZXhwcmVzc2lvbkRlZmF1bHRDdXN0b21HcmFtbWFyQk5GIiwibWV0YXN0YXRlbWVudERlZmF1bHRDdXN0b21HcmFtbWFyQk5GIiwiZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyIiwiY29tYmluZWRDdXN0b21HcmFtbWFyIiwiYm5mIiwiRmxvcmVuY2VQYXJzZXIiLCJmbG9yZW5jZVBhcnNlciIsImZsb3JlbmNlUGFyc2VyRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hciIsImNvbWJpbmVkQ3VzdG9tR3JhbW1hclJ1bGVzIiwiZ2V0UnVsZXMiLCJibmZMZXhlciIsIkJORkxleGVyIiwiZnJvbU5vdGhpbmciLCJibmZQYXJzZXIiLCJCTkZQYXJzZXIiLCJ0b2tlbnMiLCJ0b2tlbnNGcm9tQk5GIiwicnVsZXMiLCJydWxlc0Zyb21Ub2tlbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFTSxJQUFFQSxJQUFGLEdBQVdDLHlCQUFYLENBQUVELElBQUY7QUFBQSxlQUM2SUUsT0FEN0k7QUFBQSxJQUNFQywyQkFERixZQUNFQSwyQkFERjtBQUFBLElBQytCQyxnQ0FEL0IsWUFDK0JBLGdDQUQvQjtBQUFBLElBQ2lFQyxpQ0FEakUsWUFDaUVBLGlDQURqRTtBQUFBLElBQ29HQyxvQ0FEcEcsWUFDb0dBLG9DQURwRzs7QUFHTixTQUFTQyx1Q0FBVCxDQUFpREMscUJBQWpELEVBQXdFO0FBQ2hFLE1BQUVDLEdBQUYsR0FBVUMsNEJBQVYsQ0FBRUQsR0FBRjtBQUFBLE1BQ0FFLGNBREEsR0FDaUJDLDZDQUE2QyxDQUFDSCxHQUFELEVBQU1ELHFCQUFOLENBRDlEO0FBR04sU0FBT0csY0FBUDtBQUNEOztBQUVELFNBQVNDLDZDQUFULENBQXVESCxHQUF2RCxFQUE0REQscUJBQTVELEVBQW1GO0FBQ2pGLE1BQU1LLDBCQUEwQixHQUFHTCxxQkFBcUIsQ0FBQ00sUUFBdEIsRUFBbkM7QUFBQSxNQUNNQyxRQUFRLEdBQUdDLHNCQUFTQyxXQUFULEVBRGpCO0FBQUEsTUFFTUMsU0FBUyxHQUFHQyx3QkFBVUYsV0FBVixFQUZsQjtBQUFBLE1BR01HLE1BQU0sR0FBR0wsUUFBUSxDQUFDTSxhQUFULENBQXVCWixHQUF2QixDQUhmO0FBQUEsTUFJTWEsS0FBSyxHQUFHSixTQUFTLENBQUNLLGVBQVYsQ0FBMEJILE1BQTFCLENBSmQ7O0FBTUFwQixFQUFBQSxJQUFJLENBQUNzQixLQUFELEVBQVFULDBCQUFSLENBQUo7QUFFQSxNQUFNRixjQUFjLEdBQUcsSUFBSUQsNEJBQUosQ0FBbUJZLEtBQW5CLENBQXZCO0FBRUEsU0FBT1gsY0FBUDtBQUNEOztBQUVEYSxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZnRCLEVBQUFBLDJCQUEyQixFQUEzQkEsMkJBRGU7QUFFZkMsRUFBQUEsZ0NBQWdDLEVBQWhDQSxnQ0FGZTtBQUdmQyxFQUFBQSxpQ0FBaUMsRUFBakNBLGlDQUhlO0FBSWZDLEVBQUFBLG9DQUFvQyxFQUFwQ0Esb0NBSmU7QUFLZkMsRUFBQUEsdUNBQXVDLEVBQXZDQSx1Q0FMZTtBQU1mSyxFQUFBQSw2Q0FBNkMsRUFBN0NBO0FBTmUsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQk5GTGV4ZXIgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IEJORlBhcnNlciwgRmxvcmVuY2VQYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IHB1c2ggfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyB0ZXJtRGVmYXVsdEN1c3RvbUdyYW1tYXJCTkYsIHN0YXRlbWVudERlZmF1bHRDdXN0b21HcmFtbWFyQk5GLCBleHByZXNzaW9uRGVmYXVsdEN1c3RvbUdyYW1tYXJCTkYsIG1ldGFzdGF0ZW1lbnREZWZhdWx0Q3VzdG9tR3JhbW1hckJORiB9ID0gcGFyc2VycztcblxuZnVuY3Rpb24gZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCB7IGJuZiB9ID0gRmxvcmVuY2VQYXJzZXIsXG4gICAgICAgIGZsb3JlbmNlUGFyc2VyID0gZmxvcmVuY2VQYXJzZXJGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKTtcblxuICByZXR1cm4gZmxvcmVuY2VQYXJzZXI7XG59XG5cbmZ1bmN0aW9uIGZsb3JlbmNlUGFyc2VyRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBjb21iaW5lZEN1c3RvbUdyYW1tYXJSdWxlcyA9IGNvbWJpbmVkQ3VzdG9tR3JhbW1hci5nZXRSdWxlcygpLFxuICAgICAgICBibmZMZXhlciA9IEJORkxleGVyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIGJuZlBhcnNlciA9IEJORlBhcnNlci5mcm9tTm90aGluZygpLFxuICAgICAgICB0b2tlbnMgPSBibmZMZXhlci50b2tlbnNGcm9tQk5GKGJuZiksXG4gICAgICAgIHJ1bGVzID0gYm5mUGFyc2VyLnJ1bGVzRnJvbVRva2Vucyh0b2tlbnMpO1xuXG4gIHB1c2gocnVsZXMsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hclJ1bGVzKTtcblxuICBjb25zdCBmbG9yZW5jZVBhcnNlciA9IG5ldyBGbG9yZW5jZVBhcnNlcihydWxlcyk7XG5cbiAgcmV0dXJuIGZsb3JlbmNlUGFyc2VyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdGVybURlZmF1bHRDdXN0b21HcmFtbWFyQk5GLFxuICBzdGF0ZW1lbnREZWZhdWx0Q3VzdG9tR3JhbW1hckJORixcbiAgZXhwcmVzc2lvbkRlZmF1bHRDdXN0b21HcmFtbWFyQk5GLFxuICBtZXRhc3RhdGVtZW50RGVmYXVsdEN1c3RvbUdyYW1tYXJCTkYsXG4gIGZsb3JlbmNlUGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgZmxvcmVuY2VQYXJzZXJGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyXG59O1xuIl19