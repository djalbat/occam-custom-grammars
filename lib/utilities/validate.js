"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get validateBNF () {
        return validateBNF;
    },
    get validateVocabulary () {
        return validateVocabulary;
    }
});
var _necessary = require("necessary");
var _typesMap = /*#__PURE__*/ _interop_require_default(require("../typesMap"));
var _nominal = require("../utilities/nominal");
var _query = require("../utilities/query");
var _constants = require("../constants");
var _grammar = require("../utilities/grammar");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var first = _necessary.arrayUtilities.first, second = _necessary.arrayUtilities.second;
var expressionNodesQuery = (0, _query.nodesQuery)("//expression"), ruleNameTerminalNodeQuery = (0, _query.nodeQuery)("/document/rule/name/@*!"), unassignedTerminalNodeQuery = (0, _query.nodeQuery)("/expression/@unassigned"), stringLiteralTerminalNodesQuery = (0, _query.nodesQuery)("//stringLiteral/@*!"), significantTokenTypeTerminalNodesQuery = (0, _query.nodesQuery)("//significantTokenType/@*!");
function validateBNF(bnf, ruleName) {
    var content = bnf, tokens = _grammar.customGrammarBNFLexer.tokenise(content), node = _grammar.customGrammarBNFParser.parse(tokens);
    if (node === null) {
        return;
    }
    var ruleNameTerminalNode = ruleNameTerminalNodeQuery(node);
    if (ruleNameTerminalNode !== null) {
        var name = nameFromRuleNameTerminalNode(ruleNameTerminalNode);
        if (name !== ruleName) {
            throw new Error("The '".concat(name, "' rule should be named '").concat(ruleName, "'."));
        }
    }
    var types = _typesMap.default[ruleName], significantTokenTypeTerminalNodes = significantTokenTypeTerminalNodesQuery(node);
    significantTokenTypeTerminalNodes.forEach(function(significantTokenTypeTerminalNode) {
        var type = typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
            throw new Error("The '".concat(type, "' type is not included in the '").concat(ruleName, "' rule's types."));
        }
    });
    var stringLiteralTerminalNodes = stringLiteralTerminalNodesQuery(node);
    stringLiteralTerminalNodes.forEach(function(stringLiteralTerminalNode) {
        var content = contentFromStringLiteralTerminalNode(stringLiteralTerminalNode);
        if (content === _constants.BASE_TYPE_SYMBOL) {
            throw new Error('The "'.concat(content, '" string literal cannot be the same as the base type symbol.'));
        }
        var tokens = _nominal.nominalLexer.tokenise(content), tokensLength = tokens.length;
        if (tokensLength !== 1) {
            throw new Error('Tokenising the "'.concat(content, '" string literal does not result in a single token.'));
        }
        var firstToken = first(tokens), token = firstToken, type = token.getType(), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
            throw new Error('The "'.concat(content, "\" string literal's token's '").concat(type, "' type is not included in the '").concat(ruleName, "' rule's types."));
        }
    });
}
function validateVocabulary(vocabulary) {
    var content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
    if (node === null) {
        return;
    }
    var expressionNodes = expressionNodesQuery(node);
    expressionNodes.forEach(function(expressionNode) {
        var content = contentFromExpressionNode(expressionNode), tokens = _nominal.nominalLexer.tokenise(content), tokensLength = tokens.length;
        if (tokensLength > 1) {
            throw new Error("Tokenising the '".concat(content, "' content results in more than one token."));
        }
        var firstToken = first(tokens), token = firstToken, type = token.getType();
        if (type !== _constants.UNASSIGNED_TYPE) {
            throw new Error("The '".concat(type, "' type of the '").concat(content, "' token is not 'unassigned'."));
        }
        if (content === _constants.BASE_TYPE_SYMBOL) {
            throw new Error("The '".concat(content, "' token cannot be the same as the base type symbol."));
        }
    });
}
function contentFromExpressionNode(expressionNode) {
    var content;
    var unassignedTerminalNode = unassignedTerminalNodeQuery(expressionNode);
    content = unassignedTerminalNode.getContent();
    return content;
    ;
}
function nameFromRuleNameTerminalNode(ruleNameTerminalNode) {
    var name;
    var content = ruleNameTerminalNode.getContent();
    name = content; ///
    return name;
}
function contentFromStringLiteralTerminalNode(stringLiteralTerminalNode) {
    var content;
    content = stringLiteralTerminalNode.getContent();
    var matches = content.match(/"([^"]*)"/), secondMatch = second(matches);
    content = secondMatch; ///
    return content;
}
function typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode) {
    var type;
    var content = significantTokenTypeTerminalNode.getContent(), matches = content.match(/\[([^\]]*)\]/), secondMatch = second(matches);
    type = secondMatch; ///
    return type;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgdHlwZXNNYXAgZnJvbSBcIi4uL3R5cGVzTWFwXCI7XG5cbmltcG9ydCB7IG5vbWluYWxMZXhlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvbm9taW5hbFwiO1xuaW1wb3J0IHsgbm9kZVF1ZXJ5LCBub2Rlc1F1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgVU5BU1NJR05FRF9UWVBFLCBCQVNFX1RZUEVfU1lNQk9MIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY3VzdG9tR3JhbW1hckJORkxleGVyLCBjdXN0b21HcmFtbWFyQk5GUGFyc2VyLCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvZ3JhbW1hclwiO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jb25zdCBleHByZXNzaW9uTm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvL2V4cHJlc3Npb25cIiksXG4gICAgICBydWxlTmFtZVRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL2RvY3VtZW50L3J1bGUvbmFtZS9AKiFcIiksXG4gICAgICB1bmFzc2lnbmVkVGVybWluYWxOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvZXhwcmVzc2lvbi9AdW5hc3NpZ25lZFwiKSxcbiAgICAgIHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiLy9zdHJpbmdMaXRlcmFsL0AqIVwiKSxcbiAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vc2lnbmlmaWNhbnRUb2tlblR5cGUvQCohXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCTkYoYm5mLCBydWxlTmFtZSkge1xuICBjb25zdCBjb250ZW50ID0gYm5mLFxuICAgICAgICB0b2tlbnMgPSBjdXN0b21HcmFtbWFyQk5GTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgIG5vZGUgPSBjdXN0b21HcmFtbWFyQk5GUGFyc2VyLnBhcnNlKHRva2Vucyk7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBydWxlTmFtZVRlcm1pbmFsTm9kZSA9IHJ1bGVOYW1lVGVybWluYWxOb2RlUXVlcnkobm9kZSk7XG5cbiAgaWYgKHJ1bGVOYW1lVGVybWluYWxOb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgbmFtZSA9IG5hbWVGcm9tUnVsZU5hbWVUZXJtaW5hbE5vZGUocnVsZU5hbWVUZXJtaW5hbE5vZGUpO1xuXG4gICAgaWYgKG5hbWUgIT09IHJ1bGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtuYW1lfScgcnVsZSBzaG91bGQgYmUgbmFtZWQgJyR7cnVsZU5hbWV9Jy5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0eXBlcyA9IHR5cGVzTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGVzID0gc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGVzUXVlcnkobm9kZSk7XG5cbiAgc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGVzLmZvckVhY2goKHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tU2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUoc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUpLFxuICAgICAgICAgIHR5cGVzSW5jbHVkZVR5cGUgPSB0eXBlcy5pbmNsdWRlcyh0eXBlKTtcblxuICAgIGlmICghdHlwZXNJbmNsdWRlVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7dHlwZX0nIHR5cGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUncyB0eXBlcy5gKVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3Qgc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXMgPSBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVzLmZvckVhY2goKHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gY29udGVudEZyb21TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUpO1xuXG4gICAgaWYgKGNvbnRlbnQgPT09IEJBU0VfVFlQRV9TWU1CT0wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtjb250ZW50fVwiIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgYmFzZSB0eXBlIHN5bWJvbC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbnMgPSBub21pbmFsTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIGlmICh0b2tlbnNMZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW5pc2luZyB0aGUgXCIke2NvbnRlbnR9XCIgc3RyaW5nIGxpdGVyYWwgZG9lcyBub3QgcmVzdWx0IGluIGEgc2luZ2xlIHRva2VuLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSBmaXJzdCh0b2tlbnMpLFxuICAgICAgICAgIHRva2VuID0gZmlyc3RUb2tlbiwgLy8vXG4gICAgICAgICAgdHlwZSA9IHRva2VuLmdldFR5cGUoKSxcbiAgICAgICAgICB0eXBlc0luY2x1ZGVUeXBlID0gdHlwZXMuaW5jbHVkZXModHlwZSk7XG5cbiAgICBpZiAoIXR5cGVzSW5jbHVkZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtjb250ZW50fVwiIHN0cmluZyBsaXRlcmFsJ3MgdG9rZW4ncyAnJHt0eXBlfScgdHlwZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlICcke3J1bGVOYW1lfScgcnVsZSdzIHR5cGVzLmApXG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVm9jYWJ1bGFyeSh2b2NhYnVsYXJ5KSB7XG4gIGNvbnN0IGNvbnRlbnQgPSB2b2NhYnVsYXJ5LCAvLy9cbiAgICAgICAgdG9rZW5zID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgbm9kZSA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyLnBhcnNlKHRva2Vucyk7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBleHByZXNzaW9uTm9kZXMgPSBleHByZXNzaW9uTm9kZXNRdWVyeShub2RlKTtcblxuICBleHByZXNzaW9uTm9kZXMuZm9yRWFjaCgoZXhwcmVzc2lvbk5vZGUpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gY29udGVudEZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgdG9rZW5zID0gbm9taW5hbExleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICBpZiAodG9rZW5zTGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbmlzaW5nIHRoZSAnJHtjb250ZW50fScgY29udGVudCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgdG9rZW4uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IGZpcnN0KHRva2VucyksXG4gICAgICAgICAgdG9rZW4gPSBmaXJzdFRva2VuLFxuICAgICAgICAgIHR5cGUgPSB0b2tlbi5nZXRUeXBlKCk7XG5cbiAgICBpZiAodHlwZSAhPT0gVU5BU1NJR05FRF9UWVBFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHt0eXBlfScgdHlwZSBvZiB0aGUgJyR7Y29udGVudH0nIHRva2VuIGlzIG5vdCAndW5hc3NpZ25lZCcuYCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQgPT09IEJBU0VfVFlQRV9TWU1CT0wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke2NvbnRlbnR9JyB0b2tlbiBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIGJhc2UgdHlwZSBzeW1ib2wuYCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBsZXQgY29udGVudDtcblxuICBjb25zdCB1bmFzc2lnbmVkVGVybWluYWxOb2RlID0gdW5hc3NpZ25lZFRlcm1pbmFsTm9kZVF1ZXJ5KGV4cHJlc3Npb25Ob2RlKTtcblxuICBjb250ZW50ID0gdW5hc3NpZ25lZFRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7O1xufVxuXG5mdW5jdGlvbiBuYW1lRnJvbVJ1bGVOYW1lVGVybWluYWxOb2RlKHJ1bGVOYW1lVGVybWluYWxOb2RlKSB7XG4gIGxldCBuYW1lO1xuXG4gIGNvbnN0IGNvbnRlbnQgPSBydWxlTmFtZVRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBjb250ZW50RnJvbVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUoc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSkge1xuICBsZXQgY29udGVudDtcblxuICBjb250ZW50ID0gc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goL1wiKFteXCJdKilcIi8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKTtcblxuICBjb250ZW50ID0gc2Vjb25kTWF0Y2g7IC8vL1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiB0eXBlRnJvbVNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlKHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlKSB7XG4gIGxldCB0eXBlO1xuXG4gIGNvbnN0IGNvbnRlbnQgPSBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgIG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKC9cXFsoW15cXF1dKilcXF0vKSxcbiAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgdHlwZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICByZXR1cm4gdHlwZTtcbn1cbiJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUJORiIsInZhbGlkYXRlVm9jYWJ1bGFyeSIsImZpcnN0IiwiYXJyYXlVdGlsaXRpZXMiLCJzZWNvbmQiLCJleHByZXNzaW9uTm9kZXNRdWVyeSIsIm5vZGVzUXVlcnkiLCJydWxlTmFtZVRlcm1pbmFsTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidW5hc3NpZ25lZFRlcm1pbmFsTm9kZVF1ZXJ5Iiwic3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXNRdWVyeSIsInNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2Rlc1F1ZXJ5IiwiYm5mIiwicnVsZU5hbWUiLCJjb250ZW50IiwidG9rZW5zIiwiY3VzdG9tR3JhbW1hckJORkxleGVyIiwidG9rZW5pc2UiLCJub2RlIiwiY3VzdG9tR3JhbW1hckJORlBhcnNlciIsInBhcnNlIiwicnVsZU5hbWVUZXJtaW5hbE5vZGUiLCJuYW1lIiwibmFtZUZyb21SdWxlTmFtZVRlcm1pbmFsTm9kZSIsIkVycm9yIiwidHlwZXMiLCJ0eXBlc01hcCIsInNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlcyIsImZvckVhY2giLCJzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZSIsInR5cGUiLCJ0eXBlRnJvbVNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlIiwidHlwZXNJbmNsdWRlVHlwZSIsImluY2x1ZGVzIiwic3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXMiLCJzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlIiwiY29udGVudEZyb21TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlIiwiQkFTRV9UWVBFX1NZTUJPTCIsIm5vbWluYWxMZXhlciIsInRva2Vuc0xlbmd0aCIsImxlbmd0aCIsImZpcnN0VG9rZW4iLCJ0b2tlbiIsImdldFR5cGUiLCJ2b2NhYnVsYXJ5IiwiY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciIsImN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIiwiZXhwcmVzc2lvbk5vZGVzIiwiZXhwcmVzc2lvbk5vZGUiLCJjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlIiwiVU5BU1NJR05FRF9UWVBFIiwidW5hc3NpZ25lZFRlcm1pbmFsTm9kZSIsImdldENvbnRlbnQiLCJtYXRjaGVzIiwibWF0Y2giLCJzZWNvbmRNYXRjaCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O1FBbUJnQkE7ZUFBQUE7O1FBMERBQztlQUFBQTs7O3lCQTNFZTsrREFFVjt1QkFFUTtxQkFDUzt5QkFDWTt1QkFDeUU7Ozs7OztBQUUzSCxJQUFRQyxRQUFrQkMseUJBQWMsQ0FBaENELE9BQU9FLFNBQVdELHlCQUFjLENBQXpCQztBQUVmLElBQU1DLHVCQUF1QkMsSUFBQUEsaUJBQVUsRUFBQyxpQkFDbENDLDRCQUE0QkMsSUFBQUEsZ0JB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